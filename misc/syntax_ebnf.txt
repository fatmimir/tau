(* terminals *)
identifier = ? any identifier emitted by lexer (a single letter optionally followed by more letters, digits, '_' or '$') ?;
literal = ? any literal emitted by lexer (string, numeric, boolean, nil and unit) ?;
(* important: symbols and keywords (most string constants on this file) are also tokenized but not described here for brevity *)
(* notice: lexer will remove comments automatically, this may change in future to allow semantic comments *)
(* notice: lexer will automatically detect when a space and a new line are required, so we ignore them on the parser *)

(* static lookups *)
static_lookup = identifier, { "::", identifier };

(* expressions and bindings *)
type_expr = { "&" }, static_lookup;

data_expr = "(" data_expr ")" | data_prec10_expr
data_prec10_expr = data_prec20_expr, { "||", data_prec20_expr };
data_prec20_expr = data_prec30_expr, { "&&", data_prec30_expr };
data_prec30_expr = data_prec40_expr, { "==", data_prec40_expr | "!=", data_prec40_expr };
data_prec40_expr = data_prec50_expr, {
    ">", data_prec50_expr
    | "<", data_prec50_expr
    | ">=", data_prec50_expr
    | "<=", data_prec50_expr
};
data_prec50_expr = data_prec60_expr, { "|", data_prec60_expr | "^", data_prec60_expr };
data_prec60_expr = data_prec70_expr, { "&", data_prec70_expr };
data_prec70_expr = data_prec80_expr, { ">>", data_prec80_expr | "<<", data_prec80_expr };
data_prec80_expr = data_prec80_expr, { "+", data_prec90_expr | "-", data_prec90_expr  };
data_prec90_expr = data_prec100_expr, {
    "*", data_prec100_expr
    | "/", data_prec100_expr
    | "%", data_prec100_expr
};
data_prec100_expr = { "+" | "-" | "&" | "!" | "~" }, data_primary_expr;
data_primary_expr = data_lookup_expr, { passing_args };
data_lookup_expr = data_atom_expr, { "::" data_primary_expr | "." data_primary_expr };
data_atom_expr = identifier | literal;

(* arguments *)
formal_args = "(", { identifier, type_bind "," }, ")";
passing_args = "(", { data_expr, "," }, ")";

(* bindings *)
type_bind = ":", type_expr;
data_bind = "=", data_expr;

(* statements *)
return_stmt = "return", spaces, data_expr;
continue_stmt = "continue";
break_stmt = "break";
assign_stmt = data_lookup_expr, ("=" | "+=" | "-=" | "*=" | "/=" | ">>=" | "<<=" | "&=" | "|="), data_expr;
call_stmt = (data_lookup_expr | '(' data_expr ')'), { passing_args };
line_stmt = (break_stmt | continue_stmt | return_stmt | call_stmt) eol;

branch_cond_stmt = "if", data_expr, block, { "elif", data_expr, block }, [ "else" block ];
branch_loop_stmt = "loop" block;
block_stmt = branch_cond_stmt | branch_loop_stmt;

(* code blocks and declaration suffixes *)
block = "{", { let_decl | proc_decl | line_stmt | block_stmt }, "}";
prototype_suffix = "prototype", eol;
data_bind_suffix = data_bind, eol;

(* declarations *)
module_decl = "module", spaces, static_lookup, eol;
let_decl = "let", spaces, identifier, type_bind, (data_bind_suffix | prototype_suffix);
proc_decl = "proc", spaces, identifier, formal_args,
				type_bind, (block | data_bind_suffix | prototype_suffix);
extern_decl = "extern", spaces, ( let_decl | proc_decl );

(* file level *)
decls = { (extern_decl | let_decl | proc_decl), eol };
compilation_unit = module_decl, decls eof;
