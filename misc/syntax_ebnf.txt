(* terminals *)
identifier = ? any identifier emitted by lexer (a single letter optionally followed by more letters, digits, '_' or '$') ?;
literal = ? any literal emitted by lexer (string, numeric, boolean, nil and unit) ?;
(* important: symbols and keywords (most string constants on this file) are also tokenized but not described here for brevity *)
(* notice: lexer will remove comments automatically, this may change in future to allow semantic comments *)
(* notice: lexer will automatically detect when a space and a new line are required, so we ignore them on the parser *)

(* args and lookups *)
passing_args = "(" [expr, {",", expr}, [","]], ")";
index_lookup = "[" expr "]";

(* expressions *)
expr = cast_expr
cast_expr = log_or_expr { "as", log_or_expr };
log_or_expr = log_and_expr, { "||", log_and_expr };
log_and_expr = rel_expr, { "&&", rel_expr };
rel_expr = cmp_expr, { "==", bit_or_expr | "!=", bit_or_expr };
bit_or_expr = bit_and_expr, { "|" bit_and_expr | "^" bit_and_expr };
bit_and_expr = bit_shift_expr, { "&" bit_shift_expr };
bit_shift_expr = fact_expr, { "+" fact_expr | "-" fact_expr };
fact_expr = term_expr, { "*" proof_expr | "/" proof_expr | "%" proof_expr };
proof_expr = static_lookup_expr, { ":" static_lookup_expr };
value_lookup_expr = static_lookup_expr, { "." static_lookup_expr };
static_lookup_expr = unary_expr, { "::" unary_expr };
unary_expr = {"+" | "-" | "!" | "~" | "&"}, call_expr;
call_expr = index_expr, { passing_args };
index_expr = primary_expr, { index_lookup };
primary_expr = "(" expr ")" | atom;
atom = identifier | literal;

(* statements *)
return_stmt = "return" expr;
continue_stmt = "continue";
break_stmt = "break";
if_stmt = "if" main_case, {elif_case}, [else_case];
main_case = expr, block;
elif_case = "elif", expr, block;
else_case = "else", block;
while_stmt = "while", expr, block;

(* bindings *)
type_bind = ":", expr;
data_bind = "=", expr;

(* code block *)
statement_or_decl = statement | decl;
block = "{", { statement_or_decl, eol }, "}";

(* deconstruction *)
let_deconstruction = identifier, type_bind;
proc_signature = formal_arg_list, type_bind;
formal_arg_list = "(", [formal_arg_item, {",", formal_arg_item}, [","]], ")";
formal_arg_item = identifier, type_bind, ",";
proc_deconstruction = identifier, proc_signature;
type_deconstruction = identifier;

(* root declarations *)
module_decl = "module", static_lookup_expr;

(* declarations *)
let_decl = "let", let_deconstruction, ("prototype" | data_bind);
proc_decl = "proc", proc_deconstruction, ("prototype" | data_bind | block);
type_decl = "type", type_deconstruction, ("prototype" | data_bind);
decl = module_decl | let_decl | proc_decl;

(* compilation_unit *)
compilation_unit = module_decl, eol, { decl, eol } eof;